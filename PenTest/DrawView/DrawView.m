//
//  DrawView.m
//  PenTestExtension
//
//  Created by Luidia on 2018. 05. 04..
//  Copyright © 2018년 Luidia. All rights reserved.
//

#import "DrawView.h"
#import "PNFPenLibExtension.h"
#import "DrawViewController.h"

@interface DrawView ()
{
    UIColor* penColor;
    UILabel* hoveringFocus;
    NSTimer* hoveringTimer;
}
@property (retain) UIColor* penColor;
@property (readwrite, retain) UILabel* hoveringFocus;
@end

@implementation DrawView
@synthesize penColor;
@synthesize hoveringFocus;

- (id)initWithFrame:(CGRect)frame
{
    self = [super initWithFrame:frame];
    if (self) {
        self.penColor = [UIColor blackColor];
        [self InitCanvas];
    }
    return self;
}
-(void) awakeFromNib {
    [super awakeFromNib];
    [self InitCanvas];
}
-(void) dealloc {
    [self releaseHoverHideTimer];
    [self.hoveringFocus removeFromSuperview];
    self.hoveringFocus = nil;
    self.penColor = nil;
    if (m_LyrMain) CGLayerRelease(m_LyrMain);
    if (m_CtxMain) CGContextRelease(m_CtxMain);
    [super dealloc];
}

-(void) changeDrawingSize {
    [self clear];
    if (m_LyrMain) CGLayerRelease(m_LyrMain);
    if (m_CtxMain) CGContextRelease(m_CtxMain);
    m_LyrMain = nil;
    m_CtxMain = nil;
    
    [self InitCanvas];
}
-(void) SetController:(DrawViewController *) pController
{
    m_Controller = pController;
}

-(void) InitCanvas
{
    hoveringTimer = nil;
    
    if(self.hoveringFocus == nil){
        self.hoveringFocus = [[[UILabel alloc] initWithFrame:CGRectMake(0, 0, 6, 6)] autorelease];
        self.hoveringFocus.backgroundColor = [UIColor colorWithRed:0/255.0 green:0 blue:0 alpha:1.0];
        self.hoveringFocus.layer.cornerRadius = 4.0f;
        self.hoveringFocus.clipsToBounds = YES;
        [self addSubview:self.hoveringFocus];
    }
    
    self.hoveringFocus.hidden = YES;
    
    [self CreateBitmap];
}

-(void) clear
{
    CGRect frame = scaleRect(self.bounds);
    CGContextClearRect(m_CtxLyr, frame);
    [self setNeedsDisplay];
}

-(void) CreateBitmap
{
    CGRect frame = scaleRect(self.bounds);
    
    if (m_CtxMain) {
        CGContextRelease(m_CtxMain);
    }
    
    CGColorSpaceRef colorspace = CGColorSpaceCreateDeviceRGB();
    m_CtxMain = CGBitmapContextCreate(nil,
                                      frame.size.width,
                                      frame.size.height,
                                      8,
                                      4*frame.size.width,
                                      colorspace,
                                      kCGImageAlphaPremultipliedLast|kCGBitmapByteOrder32Big);
    m_LyrMain = CGLayerCreateWithContext(m_CtxMain, frame.size, nil);
    m_CtxLyr = CGLayerGetContext(m_LyrMain);
    CGColorSpaceRelease(colorspace);
    CGContextSetLineDash(m_CtxLyr, 0, nil, 0);
    CGContextSetAllowsAntialiasing(m_CtxLyr, YES);
    CGContextSetShouldAntialias(m_CtxLyr, YES);
    CGContextSetRGBStrokeColor(m_CtxLyr, 0.0,0,0,1.0);
    CGContextSetLineWidth(m_CtxLyr, 2.0);
    CGContextSetLineJoin(m_CtxLyr, kCGLineJoinRound);
    CGContextSetLineCap(m_CtxLyr, kCGLineCapRound);
}

// Only override drawRect: if you perform custom drawing.
// An empty implementation adversely affects performance during animation.
- (void)drawRect:(CGRect)rect
{
    CGContextRef ctx = UIGraphicsGetCurrentContext();
    CGContextDrawLayerInRect(ctx, [self bounds], m_LyrMain);
}

-(void) DoPenProcess:(int) penTip pressure:(int)pressure X:(float) x Y:(float) y color:(UIColor*)color erase:(BOOL)erase eraseSize:(float)eraseSize
{
    if (isnan(x) || isnan(y))
        return;
    
    switch (penTip) {
        case PEN_DOWN: {
            self.hoveringFocus.hidden = YES;
            
            drawPenCnt = 0;
            
            m_ptPrev1=CGPointMake(x, y);
            m_ptPrev2=CGPointMake(x, y);
            m_ptNew=CGPointMake(x, y);
            
            if (erase) {
                CGContextSetRGBStrokeColor(m_CtxLyr, 1,1,1,1);
                CGContextSetLineWidth(m_CtxLyr, eraseSize);
            }
            else {
                if (color) {
                    CGFloat r, g, b, a;
                    [color getRed:&r green:&g blue:&b alpha:&a];
                    CGContextSetRGBStrokeColor(m_CtxLyr, r, g, b, 1.0);
                }
                else {
                    CGContextSetRGBStrokeColor(m_CtxLyr, 0.0,0,0,1.0);
                }
                CGContextSetLineWidth(m_CtxLyr, 2.0);
            }
            break;
        }
        case PEN_MOVE: {
            self.hoveringFocus.hidden = YES;
            CGContextBeginPath(m_CtxLyr);
            
            if(drawPenCnt == 0){
                m_ptPrev2 = CGPointMake(m_ptPrev1.x, m_ptPrev1.y);
                m_ptNew = CGPointMake(x, y);
            }else{
                m_ptPrev2 = CGPointMake(m_ptPrev1.x, m_ptPrev1.y);
                m_ptPrev1 = CGPointMake(m_ptNew.x, m_ptNew.y);
                m_ptNew = CGPointMake(x, y);
            }
            
            CGPoint mid1 = BizMidPoint(m_ptPrev1, m_ptPrev2);
            CGPoint mid2 = BizMidPoint(m_ptNew, m_ptPrev1);
            CGContextMoveToPoint(m_CtxLyr, mid1.x, mid1.y);
            CGContextAddQuadCurveToPoint(m_CtxLyr, m_ptPrev1.x, m_ptPrev1.y, mid2.x, mid2.y);
            
            CGContextStrokePath(m_CtxLyr);
            
            drawPenCnt++;
            [self setNeedsDisplay];
            break;
        }
        case PEN_UP: {
            self.hoveringFocus.hidden = YES;
            CGContextBeginPath(m_CtxLyr);
            
            m_ptPrev2 = CGPointMake(m_ptPrev1.x, m_ptPrev1.y);
            m_ptPrev1 = CGPointMake(m_ptNew.x, m_ptNew.y);
            m_ptNew = CGPointMake(x, y);
            
            CGPoint mid1 = BizMidPoint(m_ptPrev1, m_ptPrev2);
            CGPoint mid2 = BizMidPoint(m_ptNew, m_ptPrev1);
            CGContextMoveToPoint(m_CtxLyr, mid1.x, mid1.y);
            CGContextAddQuadCurveToPoint(m_CtxLyr, m_ptPrev1.x, m_ptPrev1.y, mid2.x, mid2.y);
            CGContextAddLineToPoint(m_CtxLyr, m_ptNew.x, m_ptNew.y);
            
            CGContextStrokePath(m_CtxLyr);
            
            drawPenCnt = 0;
            [self setNeedsDisplay];
            break;
        }
        case PEN_HOVER: {
            self.hoveringFocus.hidden = NO;
            self.hoveringFocus.center = scaleDownPoint(CGPointMake(x, y));
            [self initHoverHideTimer];
            break;
        }
        default:
            break;
    }
}

CGPoint BizMidPoint(CGPoint pt,CGPoint pt2)
{
    return CGPointMake((pt.x + pt2.x)/2.f, (pt.y + pt2.y)/2.f);
}

-(void) releaseHoverHideTimer {
    if(hoveringTimer != nil){
        [hoveringTimer invalidate];
        [hoveringTimer release];
        hoveringTimer = nil;
    }
}
-(void) initHoverHideTimer {
    [self releaseHoverHideTimer];
    if (hoveringTimer == nil) {
        hoveringTimer = [[NSTimer scheduledTimerWithTimeInterval:0.5f
                                                          target:self
                                                        selector:@selector(onTimer:)
                                                        userInfo:nil
                                                         repeats:NO] retain];
    }
}
- (void) onTimer:(NSTimer *)timer {
    self.hoveringFocus.hidden = YES;
}
@end
